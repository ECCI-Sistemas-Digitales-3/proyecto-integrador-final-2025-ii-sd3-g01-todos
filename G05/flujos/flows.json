

import time
import machine
import onewire
import ds18x20
import json
from machine import Pin 
from umqtt.robust import MQTTClient
import network
import os

# === Módulo WiFi integrado ===
def conectar_wifi():
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    
    # Configura tus credenciales WiFi aquí
    WIFI_SSID = "vivo V23 5G"  # Cambia por tu SSID
    WIFI_PASSWORD = "yeison123"  # Cambia por tu password
    
    if not wlan.isconnected():
        print('Conectando a WiFi...')
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)
        
        # Esperar hasta que se conecte
        timeout = 0
        while not wlan.isconnected():
            time.sleep(1)
            timeout += 1
            print(f'Intentando conectar... {timeout}s')
            if timeout > 20:  # 20 segundos de timeout
                print("Error: Timeout en conexión WiFi")
                return False
                
    print('Conexión WiFi exitosa!')
    print('Configuración de red:', wlan.ifconfig())
    return True

# === Conexión WiFi ===
if not conectar_wifi():
    print("Error: no se puede continuar sin conexión WiFi")
    while True:
        time.sleep(1)

# === Configuración de LEDs ===
leds = {
    "led1": Pin(15, Pin.OUT),   # GPIO15
    "led2": Pin(2, Pin.OUT),   # GPIO2
    "led3": Pin(4, Pin.OUT),   # GPIO4
    "led4": Pin(32, Pin.OUT),  # GPIO32
    "led5": Pin(35, Pin.OUT)   # GPIO35
}

# Estado inicial de los LEDs (todos apagados)
for led in leds.values():
    led.off()

# === Configuración MQTT ===
MQTT_BROKER = "10.171.40.138"  # Broker público para pruebas
# MQTT_BROKER = "192.168.1.100"   # O usa tu broker local
MQTT_PORT = 1883
MQTT_TOPIC_SUB = "esp32/leds/control"
MQTT_TOPIC_PUB = "esp32/leds/status"
CLIENT_ID = "esp32_led_controller_" + str(time.ticks_ms())

# Variables para control de timing de LEDs
led_timers = {
    "led1": {"last_change": 0, "interval": 1000, "state": False, "blink_enabled": False},
    "led2": {"last_change": 0, "interval": 1500, "state": False, "blink_enabled": False},
    "led3": {"last_change": 0, "interval": 2000, "state": False, "blink_enabled": False},
    "led4": {"last_change": 0, "interval": 2500, "state": False, "blink_enabled": False},
    "led5": {"last_change": 0, "interval": 3000, "state": False, "blink_enabled": False}
}

# === Callback para mensajes MQTT ===
def mqtt_callback(topic, msg):
    try:
        topic = topic.decode('utf-8')
        msg = msg.decode('utf-8')
        print(f"Mensaje recibido: {topic} -> {msg}")
        
        if topic == MQTT_TOPIC_SUB:
            data = json.loads(msg)
            led_id = data.get("led")
            action = data.get("action")
            interval = data.get("interval")
            
            if led_id in leds:
                if action == "on":
                    leds[led_id].on()
                    led_timers[led_id]["state"] = True
                    led_timers[led_id]["blink_enabled"] = False
                    print(f"LED {led_id} ENCENDIDO")
                    
                elif action == "off":
                    leds[led_id].off()
                    led_timers[led_id]["state"] = False
                    led_timers[led_id]["blink_enabled"] = False
                    print(f"LED {led_id} APAGADO")
                    
                elif action == "toggle":
                    current_state = leds[led_id].value()
                    leds[led_id].value(not current_state)
                    led_timers[led_id]["state"] = not current_state
                    led_timers[led_id]["blink_enabled"] = False
                    print(f"LED {led_id} ALTERNADO")
                    
                elif action == "blink":
                    if interval:
                        led_timers[led_id]["interval"] = interval
                    led_timers[led_id]["blink_enabled"] = True
                    print(f"LED {led_id} parpadeando cada {led_timers[led_id]['interval']}ms")
                
                elif action == "stop_blink":
                    led_timers[led_id]["blink_enabled"] = False
                    print(f"LED {led_id} parpadeo detenido")
                
                # Publicar estado actualizado
                publish_status()
                
    except Exception as e:
        print(f"Error procesando mensaje: {e}")

# === Publicar estado de los LEDs ===
def publish_status():
    try:
        status = {}
        for led_id, led_pin in leds.items():
            status[led_id] = {
                "state": "on" if led_pin.value() else "off",
                "blink_interval": led_timers[led_id]["interval"],
                "blink_enabled": led_timers[led_id]["blink_enabled"]
            }
        
        client.publish(MQTT_TOPIC_PUB, json.dumps(status))
        print("Estado publicado")
    except Exception as e:
        print(f"Error publicando estado: {e}")

# === Control automático de parpadeo ===
def update_led_blink():
    current_time = time.ticks_ms()
    
    for led_id, timer in led_timers.items():
        if timer["blink_enabled"]:
            if time.ticks_diff(current_time, timer["last_change"]) >= timer["interval"]:
                # Alternar estado del LED
                leds[led_id].value(not leds[led_id].value())
                timer["state"] = not timer["state"]
                timer["last_change"] = current_time

# === Conexión MQTT ===
try:
    client = MQTTClient(CLIENT_ID, MQTT_BROKER, port=MQTT_PORT, keepalive=60)
    client.set_callback(mqtt_callback)
    client.connect()
    client.subscribe(MQTT_TOPIC_SUB)
    print(f"Conectado a MQTT Broker: {MQTT_BROKER}")
    print(f"Suscrito a: {MQTT_TOPIC_SUB}")
    print(f"Client ID: {CLIENT_ID}")
    
    # Publicar estado inicial
    publish_status()
    
except Exception as e:
    print(f"Error conectando MQTT: {e}")
    while True:
        time.sleep(1)

# === Loop principal ===
print("Sistema listo. Esperando comandos...")
print("Comandos disponibles: on, off, toggle, blink, stop_blink")

last_status_publish = time.ticks_ms()
STATUS_INTERVAL = 30000  # Publicar estado cada 30 segundos

while True:
    try:
        # Verificar mensajes MQTT
        client.check_msg()
        
        # Actualizar parpadeo automático de LEDs
        update_led_blink()
        
        # Publicar estado periódicamente
        current_time = time.ticks_ms()
        if time.ticks_diff(current_time, last_status_publish) >= STATUS_INTERVAL:
            publish_status()
            last_status_publish = current_time
            
        time.sleep_ms(10)  # Pequeña pausa para evitar sobrecarga
        
    except Exception as e:
        print(f"Error en loop principal: {e}")
        time.sleep(1)
